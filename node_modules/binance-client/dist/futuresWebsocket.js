'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.userEventHandler = undefined;
var _arguments = arguments;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _lodash = require('lodash.zipobject');

var _lodash2 = _interopRequireDefault(_lodash);

var _httpClient = require('./http-client');

var _httpClient2 = _interopRequireDefault(_httpClient);

var _openWebsocket = require('./open-websocket');

var _openWebsocket2 = _interopRequireDefault(_openWebsocket);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var BASE = 'wss://fstream.binance.com';

function getStreamNameFromObj(symbolMethodObject) {
  return symbolMethodObject.symbol.toLowerCase() + '@' + symbolMethodObject.endPoint;
}

var multiStreams = function multiStreams(symbolMethodObjects, cb) {
  if (!Array.isArray(symbolMethodObjects)) {
    symbolMethodObjects = [symbolMethodObjects];
  };

  var streamsNamesPath = symbolMethodObjects.map(function (sm) {
    return getStreamNameFromObj(sm);
  }).join('/');

  var ws = (0, _openWebsocket2.default)(BASE + '/stream?streams=' + streamsNamesPath);
  ws.onmessage = function (msg) {
    var data = JSON.parse(msg);
    cb(data);
    // TODO:
  };

  return {
    ws: ws,
    subscribe: function subscribe(symbolMethodObjects) {
      if (!Array.isArray(symbolMethodObjects)) {
        symbolMethodObjects = [symbolMethodObjects];
      }
    },
    unsubscribe: function unsubscribe(symbolMethodObjects) {
      if (!Array.isArray(symbolMethodObjects)) {
        symbolMethodObjects = [symbolMethodObjects];
      }
    },
    close: function close(options) {
      ws.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    }
  };
};

// ________________________________ aggTrade
var aggTradesOutputMapping = function aggTradesOutputMapping(d) {
  return {
    eventType: d.e,
    eventTime: d.E,
    symbol: d.s,
    aggId: d.a,
    price: d.p,
    qty: d.q,
    firstTradeId: d.f,
    lastTradeId: d.l,
    tradeTime: d.T,
    isBuyerMaker: d.m
  };
};
var aggTrades = function aggTrades(symbol, cb) {
  return tradesInternal(symbol, 'aggTrade', aggTradesOutputMapping, cb);
};

// ____________________________ trade

var tradesOutputMapping = function tradesOutputMapping(d) {
  return {
    eventType: d.e,
    eventTime: d.E,
    symbol: d.s,
    tradeId: d.t,
    price: d.p,
    qty: d.q,
    tradeTime: d.T,
    isBuyerMaker: d.m
  };
};
var trades = function trades(symbol, cb) {
  return tradesInternal(symbol, 'trade', tradesOutputMapping, cb);
};

var tradesInternal = function tradesInternal(symbol, streamName, outputMap, cb) {
  var w = (0, _openWebsocket2.default)(BASE + '/ws/' + symbol.toLowerCase() + '@' + streamName);
  w.onmessage = function (msg) {
    cb(outputMap(JSON.parse(msg.data)));
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

// _______________________________ markPrice
var markPrice = function markPrice(payload, cb) {
  var symbol = payload.symbol,
      speed = payload.speed;

  var w = (0, _openWebsocket2.default)(BASE + '/ws/' + symbol.toLowerCase() + '@markPrice' + (speed ? '@' + speed : ''));

  w.onmessage = function (msg) {
    var _JSON$parse = JSON.parse(msg.data),
        eventType = _JSON$parse.e,
        eventTime = _JSON$parse.E,
        symbol = _JSON$parse.s,
        markPrice = _JSON$parse.p,
        fundingRate = _JSON$parse.r,
        nextFundingTime = _JSON$parse.T;

    cb({
      eventType: eventType,
      eventTime: eventTime,
      symbol: symbol,
      markPrice: markPrice,
      fundingRate: fundingRate,
      nextFundingTime: nextFundingTime
    });
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

// _______________________________ markPrice for all market
var markPriceAll = function markPriceAll(payload, cb) {
  var speed = payload.speed,
      reduce = payload.reduce;

  var w = (0, _openWebsocket2.default)(BASE + '/ws/!markPrice@arr' + (speed ? '@' + speed : ''));

  w.onmessage = function (msg) {
    var data = JSON.parse(msg.data).map(function (d) {
      return {
        eventType: d.e,
        eventTime: d.E,
        symbol: d.s,
        markPrice: d.p,
        fundingRate: d.r,
        nextFundingTime: d.T
      };
    });

    if (reduce) {
      var reducedData = data.reduce(function (reducedData, d) {
        reducedData[d.symbol] = d;
        return reducedData;
      }, {});

      return cb(reducedData, data);
    }
    return cb(data);
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

// _______________________________ candles (Kline/Candlestick)

var candles = function candles(symbol, interval, cb) {
  if (!symbol || !interval || !cb) {
    throw new Error('Please pass a symbol, interval and callback.');
  }

  var w = (0, _openWebsocket2.default)(BASE + '/ws/' + symbol.toLowerCase() + '@kline_' + interval);

  w.onmessage = function (msg) {
    var _JSON$parse2 = JSON.parse(msg.data),
        eventType = _JSON$parse2.e,
        eventTime = _JSON$parse2.E,
        symbol = _JSON$parse2.s,
        tick = _JSON$parse2.k;

    var startTime = tick.t,
        closeTime = tick.T,
        interval = tick.i,
        firstTradeId = tick.f,
        lastTradeId = tick.L,
        open = tick.o,
        close = tick.c,
        high = tick.h,
        low = tick.l,
        volume = tick.v,
        trades = tick.n,
        isFinal = tick.x,
        quoteAssetVolume = tick.q,
        buyAssetVolume = tick.V,
        quoteBuyAssetVolume = tick.Q;


    cb({
      eventType: eventType,
      eventTime: eventTime,
      symbol: symbol,
      startTime: startTime,
      closeTime: closeTime,
      firstTradeId: firstTradeId,
      lastTradeId: lastTradeId,
      open: open,
      high: high,
      low: low,
      close: close,
      volume: volume,
      trades: trades,
      interval: interval,
      isFinal: isFinal,
      quoteAssetVolume: quoteAssetVolume,
      buyAssetVolume: buyAssetVolume,
      quoteBuyAssetVolume: quoteBuyAssetVolume
    });
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

// _______________________________ tickers

// ____________ mini ticker
var miniTicker = function miniTicker(symbol, cb) {
  var w = (0, _openWebsocket2.default)(BASE + '/ws/' + symbol.toLowerCase() + '@miniTicker');

  w.onmessage = function (msg) {
    cb(miniTickerTransform(JSON.parse(msg.data)));
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

var allMiniTickers = function allMiniTickers(cb) {
  var w = (0, _openWebsocket2.default)(BASE + '/ws/!miniTicker@arr');

  w.onmessage = function (msg) {
    cb(JSON.parse(msg.data).map(function (d) {
      return miniTickerTransform(d);
    }));
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

var miniTickerTransform = function miniTickerTransform(d) {
  return {
    eventType: d.e,
    eventTime: d.E,
    symbol: d.s,
    close: d.c,
    open: d.o,
    high: d.h,
    low: d.l,
    volume: d.v,
    quoteVolume: d.q
  };
};

// _______ ticker
var ticker = function ticker(symbol, cb) {
  var w = (0, _openWebsocket2.default)(BASE + '/ws/' + symbol.toLowerCase() + '@ticker');

  w.onmessage = function (msg) {
    cb(tickerTransform(JSON.parse(msg.data)));
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

var allTickers = function allTickers(cb) {
  var w = new _openWebsocket2.default(BASE + '/ws/!ticker@arr');

  w.onmessage = function (msg) {
    cb(JSON.parse(msg.data).map(function (m) {
      return tickerTransform(m);
    }));
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

var tickerTransform = function tickerTransform(m) {
  return {
    eventType: m.e,
    eventTime: m.E,
    symbol: m.s,
    priceChange: m.p,
    priceChangePercent: m.P,
    weightedAvgPrice: m.w,
    lastPrice: m.c,
    lastQty: m.Q,
    open: m.o,
    high: m.h,
    low: m.l,
    volume: m.v,
    volumeQuote: m.q,
    openTime: m.O,
    closeTime: m.C,
    firstTradeId: m.F,
    lastTradeId: m.L,
    totalTrades: m.n
    // TODO:
    // prevDayClose: m.x,
    // bestBid: m.b,
    // bestBidQnt: m.B,
    // bestAsk: m.a,
    // bestAskQnt: m.A
  };
};

// ________ book Ticker
var bookTicker = function bookTicker(symbol, cb) {
  var w = (0, _openWebsocket2.default)(BASE + '/ws/' + symbol.toLowerCase() + '@bookTicker');

  w.onmessage = function (msg) {
    cb(bookTickerTransform(JSON.parse(msg.data)));
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

var allBookTicker = function allBookTicker(cb) {
  var w = (0, _openWebsocket2.default)(BASE + '/ws/!bookTicker');

  w.onmessage = function (msg) {
    cb(JSON.parse(msg.data).map(function (d) {
      return bookTickerTransform(d);
    }));
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

var bookTickerTransform = function bookTickerTransform(d) {
  return {
    updateId: d.u,
    bestBidPrice: d.b,
    bestBidQty: d.B,
    bestAskPrice: d.a,
    bestAskQty: d.A
  };
};

// ______________________________ liquidation order
var liquidationOrder = function liquidationOrder(symbol, cb) {
  var w = (0, _openWebsocket2.default)(BASE + '/ws/' + symbol.toLowerCase() + '@forceOrder');

  w.onmessage = function (msg) {
    cb(liquidationOrderTransform(JSON.parse(msg.data)));
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

var allLiquidationOrder = function allLiquidationOrder(cb) {
  var w = (0, _openWebsocket2.default)(BASE + '/ws/!forceOrder@arr');

  w.onmessage = function (msg) {
    cb(JSON.parse(msg.data).map(function (d) {
      return liquidationOrderTransform(d);
    }));
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

var liquidationOrderTransform = function liquidationOrderTransform(_ref) {
  var eventType = _ref.e,
      eventTime = _ref.E,
      o = _ref.o;
  return {
    eventType: eventType,
    eventTime: eventTime,
    order: {
      symbol: o.s,
      side: o.S,
      orderType: o.o,
      timeInForce: o.f,
      qty: o.q,
      price: o.p,
      averagePrice: o.ap,
      status: o.X,
      lastFilledQty: o.l,
      filledAccumulatedQty: o.z,
      tradeTime: o.T
    }
  };
};

// TODO: CONTINUE FROM HERE

// _______________________________ depth

var partialDepth = function partialDepth(payload, cb) {
  var symbol = payload.symbol,
      speed = payload.speed;
  var level = payload.level;

  if (!level) {
    level = 10;
  };

  var w = (0, _openWebsocket2.default)(BASE + '/ws/' + symbol.toLowerCase() + '@depth' + level + (speed && speed !== '250ms' ? '@' + speed : ''));

  w.onmessage = function (msg) {
    var _JSON$parse3 = JSON.parse(msg.data),
        eventType = _JSON$parse3.e,
        eventTime = _JSON$parse3.E,
        transactionTime = _JSON$parse3.T,
        symbol = _JSON$parse3.s,
        firstUpdateId = _JSON$parse3.U,
        finalUpdateId = _JSON$parse3.u,
        lastUpdateIdInLastStream = _JSON$parse3.pu,
        bidDepth = _JSON$parse3.b,
        askDepth = _JSON$parse3.a;

    cb({
      eventType: eventType,
      eventTime: eventTime,
      symbol: symbol,
      firstUpdateId: firstUpdateId,
      finalUpdateId: finalUpdateId,
      transactionTime: transactionTime,
      lastUpdateIdInLastStream: lastUpdateIdInLastStream,
      bidDepth: bidDepth.map(function (b) {
        return (0, _lodash2.default)(['price', 'qty'], b);
      }),
      askDepth: askDepth.map(function (a) {
        return (0, _lodash2.default)(['price', 'qty'], a);
      })
    });

    return {
      closeStream: function closeStream(options) {
        return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
      },
      ws: w
    };
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

var depth = function depth(payload, cb) {
  var symbol = payload.symbol,
      speed = payload.speed;

  var w = (0, _openWebsocket2.default)(BASE + '/ws/' + symbol.toLowerCase() + '@depth' + (speed ? '@' + speed : ''));

  w.onmessage = function (msg) {
    var _JSON$parse4 = JSON.parse(msg.data),
        eventType = _JSON$parse4.e,
        eventTime = _JSON$parse4.E,
        transactionTime = _JSON$parse4.T,
        symbol = _JSON$parse4.s,
        firstUpdateId = _JSON$parse4.U,
        finalUpdateId = _JSON$parse4.u,
        lastUpdateIdInLastStream = _JSON$parse4.pu,
        bidDepth = _JSON$parse4.b,
        askDepth = _JSON$parse4.a;

    cb({
      eventType: eventType,
      eventTime: eventTime,
      symbol: symbol,
      firstUpdateId: firstUpdateId,
      finalUpdateId: finalUpdateId,
      transactionTime: transactionTime,
      lastUpdateIdInLastStream: lastUpdateIdInLastStream,
      bidDepth: bidDepth.map(function (b) {
        return (0, _lodash2.default)(['price', 'qty'], b);
      }),
      askDepth: askDepth.map(function (a) {
        return (0, _lodash2.default)(['price', 'qty'], a);
      })
    });
  };

  return {
    closeStream: function closeStream(options) {
      return w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
    },
    ws: w
  };
};

// _____________________________________________ user data streams

var userTransforms = {
  MARGIN_CALL: function MARGIN_CALL(m) {
    return {
      eventType: 'MARGIN_CALL',
      evenTime: m.E,
      crossWalletBalance: m.cw,
      positions: m.p.map(function (p) {
        return {
          symbol: p.s,
          positionSide: p.ps,
          positionAmount: p.pa,
          marginType: p.mt,
          isolatedWallet: p.iw,
          markPrice: p.mp,
          unrealizedPnL: p.up,
          maintenanceMarginRequired: p.mm
        };
      })
    };
  },
  ACCOUNT_UPDATE: function ACCOUNT_UPDATE(m) {
    var a = m.a;
    return {
      eventType: 'ACCOUNT_UPDATE',
      eventTime: m.E,
      transactTime: m.T,
      updateData: {
        eventReasonType: a.m,
        balances: a.B.map(function (d) {
          return {
            asset: d.a,
            balance: d.wb,
            crossWalletBalance: d.cw
          };
        }),
        positions: a.P.map(function (d) {
          return {
            symbol: d.s,
            positionAmount: d.pa,
            entryPrice: d.ep,
            preAccumulatedRealizedFee: d.cr,
            marginType: d.mt,
            isolatedWallet: d.iw,
            positionSide: d.ps
          };
        })
      }
    };
  },
  ORDER_TRADE_UPDATE: function ORDER_TRADE_UPDATE(m) {
    var o = m.o;
    return {
      eventType: 'ORDER_TRADE_UPDATE',
      eventTime: m.E,
      transactTime: m.T,
      order: {
        symbol: o.s,
        clientOrderId: o.c,
        side: o.S,
        positionSide: o.ps,
        type: o.o,
        timeInForce: o.f,
        origQty: o.q,
        origPrice: o.p,
        avgPrice: o.ap,
        stopPrice: o.sp,
        execType: o.x,
        status: o.X,
        orderId: o.i,
        lastFilledQty: o.l,
        filledAccumulatedQty: o.z,
        lastFilledPrice: o.L,
        commissionAsset: o.N,
        commission: o.n,
        tradeTime: o.T,
        tradeId: o.t,
        bidNational: o.b,
        askNational: o.a,
        isMaker: o.m,
        isReduceOnly: o.R,
        stopPriceType: o.wt
      }
    };
  }
};

var userEventHandler = function userEventHandler(cb) {
  return function (msg) {
    var _JSON$parse5 = JSON.parse(msg.data),
        eventType = _JSON$parse5.e,
        rest = _objectWithoutProperties(_JSON$parse5, ['e']);

    cb(userTransforms[eventType] ? userTransforms[eventType](rest) : _extends({ eventType: eventType }, rest));
  };
};

exports.userEventHandler = userEventHandler;
var user = function user(opts) {
  return function (cb) {
    var recvWindow = void 0;
    if (_arguments.length === 2) {
      recvWindow = _arguments[0].recvWindow;
      cb = _arguments[1];
    }

    var _httpMethods = (0, _httpClient2.default)(opts),
        futuresGetUserDataStream = _httpMethods.futuresGetUserDataStream,
        futuresKeepUserDataStream = _httpMethods.futuresKeepUserDataStream,
        futuresCloseUserDataStream = _httpMethods.futuresCloseUserDataStream;

    var currentListenKey = null;
    var int = null;
    var w = null;

    var handleEvent = function handleEvent(msg) {
      var _JSON$parse6 = JSON.parse(msg.data),
          type = _JSON$parse6.e,
          rest = _objectWithoutProperties(_JSON$parse6, ['e']);

      if (type === 'listenKeyExpired') {
        keepAlive(false);
        return;
      }
      cb(userTransforms[type] ? userTransforms[type](rest) : _extends({ type: type }, rest));
    };

    var _futuresKeepUserDataStream = function _futuresKeepUserDataStream() {
      if (recvWindow) {
        return futuresKeepUserDataStream({ recvWindow: recvWindow });
      }
      return futuresKeepUserDataStream();
    };

    var keepAlive = function keepAlive(isReconnecting) {
      if (currentListenKey) {
        clearInterval(int);
        _futuresKeepUserDataStream().catch(function () {
          closeStream({}, true);

          if (isReconnecting) {
            setTimeout(function () {
              return makeStream(true);
            }, 30e3);
          } else {
            makeStream(true);
          }
        });
      }
    };

    var _futuresCloseUserDataStream = function _futuresCloseUserDataStream() {
      if (recvWindow) {
        return futuresCloseUserDataStream({ recvWindow: recvWindow });
      }
      return futuresCloseUserDataStream();
    };

    var closeStream = function closeStream(options, catchErrors) {
      if (currentListenKey) {
        clearInterval(int);

        var p = _futuresCloseUserDataStream();

        if (catchErrors) {
          p.catch(function (f) {
            return f;
          });
        }

        w.close(1000, 'Close handle was called', _extends({ keepClosed: true }, options));
        currentListenKey = null;
      }
    };

    var _futuresGetUserDataStream = function _futuresGetUserDataStream() {
      if (recvWindow) {
        return futuresGetUserDataStream({ recvWindow: recvWindow });
      }
      return futuresGetUserDataStream();
    };

    var makeStream = function makeStream(isReconnecting) {
      return new Promise(function (resolve) {
        _futuresGetUserDataStream().then(function (_ref2) {
          var listenKey = _ref2.listenKey;

          w = (0, _openWebsocket2.default)(BASE + '/ws/' + listenKey);
          w.onmessage = function (msg) {
            return handleEvent(msg);
          };

          currentListenKey = listenKey;

          if (!int) {
            int = setInterval(function () {
              return keepAlive(false);
            }, 55 * 60 * 50e3);
          }
          // TODO: think about using only listenKeyExpired

          resolve({
            closeStream: function (_closeStream) {
              function closeStream(_x) {
                return _closeStream.apply(this, arguments);
              }

              closeStream.toString = function () {
                return _closeStream.toString();
              };

              return closeStream;
            }(function (options) {
              return closeStream(options);
            }),
            ws: w
          });
        }).catch(function (err) {
          if (isReconnecting) {
            setTimeout(function () {
              resolve(makeStream(true));
            }, 30e3);
          } else {
            throw err;
          }
        });
      });
    };

    return makeStream(false);
  };
};

exports.default = function (opts) {
  return {
    depth: depth,
    partialDepth: partialDepth,
    markPrice: markPrice,
    markPriceAll: markPriceAll,
    candles: candles,
    trades: trades,
    aggTrades: aggTrades,
    ticker: ticker,
    miniTicker: miniTicker,
    allMiniTickers: allMiniTickers,
    allTickers: allTickers,
    bookTicker: bookTicker,
    allBookTicker: allBookTicker,
    liquidationOrder: liquidationOrder,
    allLiquidationOrder: allLiquidationOrder,
    user: user(opts),
    multiStreams: multiStreams
  };
};