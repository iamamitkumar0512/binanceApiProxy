'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.candleFields = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _lodash = require('lodash.zipobject');

var _lodash2 = _interopRequireDefault(_lodash);

require('isomorphic-fetch');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var BASE = 'https://api.binance.com';
var FUTURE_BASE = 'https://fapi.binance.com';
var API_PATH_BASE = 'api';
var FUTURES_API_PATH_BASE = 'fapi';

var defaultGetTime = function defaultGetTime() {
  return Date.now();
};

/**
 * Build query string for uri encoded url based on json object
 */
var makeQueryString = function makeQueryString(q) {
  return q ? '?' + Object.keys(q).filter(function (k) {
    return !!q[k];
  }).map(function (k) {
    return encodeURIComponent(k) + '=' + encodeURIComponent(q[k]);
  }).join('&') : '';
};

/**
 * Finalize API response
 */
var sendResult = function sendResult(call) {
  return call.then(function (res) {
    // If response is ok, we can safely assume it is valid JSON
    // TODO: add headers easy access
    if (res.ok) {
      return res.json();
    }

    // Errors might come from the API itself or the proxy Binance is using.
    // For API errors the response will be valid JSON,but for proxy errors
    // it will be HTML
    return res.text().then(function (text) {
      var error = void 0;
      try {
        var json = JSON.parse(text);
        // The body was JSON parsable, assume it is an API response error
        error = new Error(json.msg || res.status + ' ' + res.statusText);
        error.code = json.code;
      } catch (e) {
        // The body was not JSON parsable, assume it is proxy error
        error = new Error(res.status + ' ' + res.statusText + ' ' + text);
        error.response = res;
        error.responseText = text;
      }
      throw error;
    });
  });
};

/**
 * Util to validate existence of required parameter(s)
 */
var checkParams = function checkParams(name, payload) {
  var requires = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (!payload) {
    throw new Error('You need to pass a payload object.');
  }

  requires.forEach(function (r) {
    if (!payload[r] && isNaN(payload[r])) {
      throw new Error('Method ' + name + ' requires ' + r + ' parameter.');
    }
  });

  return true;
};

/**
 * Make public calls against the api
 *
 * @param {string} path Endpoint path
 * @param {object} data The payload to be sent
 * @param {string} method HTTB VERB, GET by default
 * @param {object} headers
 * @returns {object} The api response
 */
var publicCall = function publicCall(_ref) {
  var base = _ref.base,
      apiPathBase = _ref.apiPathBase;
  return function (_ref2) {
    var path = _ref2.path,
        data = _ref2.data,
        _ref2$method = _ref2.method,
        method = _ref2$method === undefined ? 'GET' : _ref2$method,
        _ref2$headers = _ref2.headers,
        headers = _ref2$headers === undefined ? {} : _ref2$headers,
        agent = _ref2.agent;
    return sendResult(fetch(base + '/' + apiPathBase + path + makeQueryString(data), {
      method: method,
      json: true,
      headers: headers,
      agent: agent
    }));
  };
};

/**
 * Factory method for partial private calls against the api
 *
 * @param {string} path Endpoint path
 * @param {object} data The payload to be sent
 * @param {string} method HTTB VERB, GET by default
 * @param {http.Agent} object http Agent object (can be used to setup proxy use) 
 * @returns {object} The api response
 */
var keyCall = function keyCall(_ref3) {
  var apiKey = _ref3.apiKey,
      pubCall = _ref3.pubCall;
  return function (_ref4) {
    var path = _ref4.path,
        data = _ref4.data,
        _ref4$method = _ref4.method,
        method = _ref4$method === undefined ? 'GET' : _ref4$method,
        agent = _ref4.agent;

    if (!apiKey) {
      throw new Error('You need to pass an API key to make this call.');
    }

    return pubCall({
      path: path,
      data: data,
      method: method,
      headers: {
        'X-MBX-APIKEY': apiKey
      },
      agent: agent
    });
  };
};

/**
 * Factory method for private calls against the api
 *
 * @param {string} path Endpoint path
 * @param {object} data The payload to be sent
 * @param {string} method HTTB VERB, GET by default
 * @param {object} headers
 * @returns {object} The api response
 */
var privateCall = function privateCall(_ref5) {
  var apiKey = _ref5.apiKey,
      apiSecret = _ref5.apiSecret,
      base = _ref5.base,
      apiPathBase = _ref5.apiPathBase,
      _ref5$getTime = _ref5.getTime,
      getTime = _ref5$getTime === undefined ? defaultGetTime : _ref5$getTime,
      pubCall = _ref5.pubCall;
  return function (_ref6) {
    var path = _ref6.path,
        _ref6$data = _ref6.data,
        data = _ref6$data === undefined ? {} : _ref6$data,
        _ref6$method = _ref6.method,
        method = _ref6$method === undefined ? 'GET' : _ref6$method,
        noData = _ref6.noData,
        noExtra = _ref6.noExtra,
        agent = _ref6.agent;

    if (!apiKey || !apiSecret) {
      throw new Error('You need to pass an API key and secret to make authenticated calls.');
    }

    return (data && data.useServerTime ? pubCall({ path: '/v1/time', agent: agent }).then(function (r) {
      return r.serverTime;
    }) : Promise.resolve(getTime())).then(function (timestamp) {
      if (data) {
        delete data.useServerTime;
      }

      var signature = _crypto2.default.createHmac('sha256', apiSecret).update(makeQueryString(_extends({}, data, { timestamp: timestamp })).substr(1)).digest('hex');

      var newData = noExtra ? data : _extends({}, data, { timestamp: timestamp, signature: signature });

      return sendResult(fetch('' + base + (path.includes('/wapi') || path.includes('/sapi') ? '' : '/' + apiPathBase) + path + (noData ? '' : makeQueryString(newData)), {
        method: method,
        headers: { 'X-MBX-APIKEY': apiKey },
        json: true,
        agent: agent
      }));
    });
  };
};

var candleFields = exports.candleFields = ['openTime', 'open', 'high', 'low', 'close', 'volume', 'closeTime', 'quoteAssetVolume', // TODO: update the doc
'trades', 'buyBaseAssetVolume', 'buyQuoteAssetVolume'];

/**
 * Get candles for a specific pair and interval and convert response
 * to a user friendly collection.
 */
var _candles = function _candles(pubCall, payload, agent) {
  return pubCall({ path: '/v1/klines', data: payload, agent: agent }).then(function (candles) {
    return candles.map(function (candle) {
      return (0, _lodash2.default)(candleFields, candle);
    });
  });
};

/**
 * Create a new order wrapper for market order simplicity
 */
var _order = function _order(privCall) {
  var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var url = arguments[2];
  var agent = arguments[3];

  var newPayload = ['LIMIT', 'STOP_LOSS_LIMIT', 'TAKE_PROFIT_LIMIT'].includes(payload.type) || !payload.type ? // TODO: check
  _extends({ timeInForce: 'GTC' }, payload) : payload;
  return checkParams('order', newPayload, ['symbol', 'side', 'quantity']) && privCall({
    path: url, data: _extends({ type: 'LIMIT' }, newPayload), method: 'POST', agent: agent }); // TODO: check params
};

/**
 * Zip asks and bids response from order book
 */
var _book = function _book(pubCall, payload, agent) {
  return pubCall({ path: '/v1/depth', data: payload, agent: agent }).then(function (_ref7) {
    var lastUpdateId = _ref7.lastUpdateId,
        asks = _ref7.asks,
        bids = _ref7.bids;
    return {
      lastUpdateId: lastUpdateId,
      asks: asks.map(function (a) {
        return (0, _lodash2.default)(['price', 'qty'], a);
      }),
      bids: bids.map(function (b) {
        return (0, _lodash2.default)(['price', 'qty'], b);
      })
    };
  });
};

var _aggTrades = function _aggTrades(pubCall, payload, agent) {
  return pubCall({ path: '/v1/aggTrades', data: payload, agent: agent }).then(function (trades) {
    return trades.map(function (trade) {
      return {
        aggId: trade.a,
        price: trade.p,
        qty: trade.q,
        firstTradeId: trade.f, // TODO: change the doc (And Exchange api)
        lastTradeId: trade.l,
        time: trade.T,
        isBuyerMaker: trade.m
      };
    });
  });
};

var _futuresCandles = _candles;
/**
 * Create a new order wrapper for market order simplicity
 */
var _futuresOrder = function _futuresOrder(privCall) {
  var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var url = arguments[2];
  var agent = arguments[3];

  var newPayload = ['LIMIT', 'STOP', 'TAKE_PROFIT'].includes(payload.type) || !payload.type ? // TODO: TO CHECK
  _extends({ timeInForce: 'GTC' }, payload) : payload;

  if (!payload.type) payload.type = 'LIMIT';

  if (payload.type && payload.type === 'MARKET' && payload.timeInForce) {
    throw new Error('timeInForce parameter cannot be send with type MARKET');
  }

  return checkParams('futuresOrder', newPayload, ['symbol', 'side', 'type', 'quantity'].concat(_toConsumableArray(payload.type && payload.type === 'LIMIT' && ['price', 'timeInForce'] || []), _toConsumableArray(payload.type && ['STOP', 'TAKE_PROFIT'].includes(payload.type) && ['price', 'stopPrice'] || []), _toConsumableArray(payload.type && ['STOP_MARKET', 'TAKE_PROFIT_MARKET'].includes(payload.type) && ['stopPrice'] || []))) && privCall({ path: url, data: newPayload, method: 'POST', agent: agent });
};
var _futuresBook = _book;
var _futuresAggTrades = _aggTrades;

exports.default = function (opts) {
  var base = opts && opts.httpBase || BASE;
  var futureBase = opts && opts.httpFutureBase || FUTURE_BASE;
  var pubCall = publicCall(_extends({}, opts, { base: base, apiPathBase: API_PATH_BASE }));
  var privCall = privateCall(_extends({}, opts, { base: base, apiPathBase: API_PATH_BASE, pubCall: pubCall }));
  var kCall = keyCall(_extends({}, opts, { pubCall: pubCall }));
  var futuresPubCall = publicCall(_extends({}, opts, { base: futureBase, apiPathBase: FUTURES_API_PATH_BASE }));
  var futuresPrivCall = privateCall(_extends({}, opts, { base: futureBase, apiPathBase: FUTURES_API_PATH_BASE, pubCall: futuresPubCall }));
  var futuresKCall = keyCall(_extends({}, opts, { pubCall: futuresPubCall }));

  return {
    // _______________________________________ normal binance api
    ping: function ping(agent) {
      return pubCall({ path: '/v1/ping', agent: agent }).then(function () {
        return true;
      });
    },
    time: function time(agent) {
      return pubCall({ path: '/v1/time', agent: agent }).then(function (r) {
        return r.serverTime;
      });
    },
    exchangeInfo: function exchangeInfo(agent) {
      return pubCall({ path: '/v3/exchangeInfo', agent: agent });
    },
    book: function book(payload, agent) {
      return checkParams('book', payload, ['symbol']) && _book(pubCall, payload, agent);
    },
    trades: function trades(payload, agent) {
      return checkParams('trades', payload, ['symbol']) && pubCall({ path: '/v1/trades', data: payload, agent: agent });
    },
    tradesHistory: function tradesHistory(payload, agent) {
      return checkParams('tradesHistory', payload, ['symbol']) && kCall({ path: '/v1/historicalTrades', data: payload, agent: agent });
    },
    aggTrades: function aggTrades(payload, agent) {
      return checkParams('aggTrades', payload, ['symbol']) && _aggTrades(pubCall, payload, agent);
    },
    candles: function candles(payload, agent) {
      return checkParams('candles', payload, ['symbol', 'interval']) && _candles(pubCall, payload, agent);
    },
    dailyStats: function dailyStats(payload, agent) {
      return pubCall({ path: '/v1/ticker/24hr', data: payload, agent: agent });
    },
    prices: function prices(agent) {
      return pubCall({ path: '/v1/ticker/allPrices', agent: agent }).then(function (r) {
        return r.reduce(function (out, cur) {
          return out[cur.symbol] = cur.price, out;
        }, {});
      });
    },
    avgPrice: function avgPrice(payload, agent) {
      return pubCall({ path: '/v3/avgPrice', data: payload, agent: agent });
    },
    allBookTickers: function allBookTickers(agent) {
      return pubCall({ path: '/v1/ticker/allBookTickers', agent: agent }).then(function (r) {
        return r.reduce(function (out, cur) {
          return out[cur.symbol] = cur, out;
        }, {});
      });
    },
    order: function order(payload, agent) {
      return _order(privCall, payload, '/v3/order', agent);
    },
    orderTest: function orderTest(payload, agent) {
      return _order(privCall, payload, '/v3/order/test', agent);
    },
    getOrder: function getOrder(payload, agent) {
      return privCall({
        path: '/v3/order', data: payload, method: 'GET', agent: agent });
    },
    cancelOrder: function cancelOrder(payload, agent) {
      return privCall({
        path: '/v3/order', data: payload, method: 'DELETE', agent: agent });
    },
    openOrders: function openOrders(payload, agent) {
      return privCall({
        path: '/v3/openOrders', data: payload, method: 'GET', agent: agent });
    }, // TODO: to check (cancel)
    allOrders: function allOrders(payload, agent) {
      return privCall({
        path: '/v3/allOrders', data: payload, method: 'GET', agent: agent });
    },
    accountInfo: function accountInfo(payload, agent) {
      return privCall({
        path: '/v3/account', data: payload, method: 'GET', agent: agent });
    },
    myTrades: function myTrades(payload, agent) {
      return privCall({
        path: '/v3/myTrades', data: payload, method: 'GET', agent: agent });
    },
    withdraw: function withdraw(payload, agent) {
      return privCall({
        path: '/wapi/v3/withdraw.html', data: payload, method: 'POST', agent: agent });
    },
    withdrawHistory: function withdrawHistory(payload, agent) {
      return privCall({ path: '/wapi/v3/withdrawHistory.html', data: payload, method: 'GET', agent: agent });
    },
    depositHistory: function depositHistory(payload, agent) {
      return privCall({ path: '/wapi/v3/depositHistory.html', data: payload, method: 'GET', agent: agent });
    },
    depositAddress: function depositAddress(payload, agent) {
      return privCall({ path: '/wapi/v3/depositAddress.html', data: payload, method: 'GET', agent: agent });
    },
    tradeFee: function tradeFee(payload, agent) {
      return privCall({ path: '/wapi/v3/tradeFee.html', data: payload, method: 'GET', agent: agent }).then(function (res) {
        return res.tradeFee;
      });
    },
    assetDetail: function assetDetail(payload, agent) {
      return privCall({ path: '/wapi/v3/assetDetail.html', data: payload, method: 'GET', agent: agent });
    },
    getDataStream: function getDataStream(agent) {
      return privCall({ path: '/v1/userDataStream', data: null, method: 'POST', noData: true, agent: agent });
    },
    keepDataStream: function keepDataStream(payload, agent) {
      return privCall({ path: '/v1/userDataStream', data: payload, method: 'PUT', noData: false, noExtraData: true, agent: agent });
    },
    closeDataStream: function closeDataStream(payload, agent) {
      return privCall({ path: '/v1/userDataStream', data: payload, method: 'DELETE', noData: false, noExtraData: true, agent: agent });
    },

    // ______________________________________ futures binance api

    futuresPing: function futuresPing(agent) {
      return futuresPubCall({ path: '/v1/ping', method: 'GET', agent: agent }).then(function () {
        return true;
      });
    },
    futuresTime: function futuresTime(agent) {
      return futuresPubCall({ path: '/v1/time', method: 'GET', agent: agent }).then(function (r) {
        return r.serverTime;
      });
    },
    futuresExchangeInfo: function futuresExchangeInfo(agent) {
      return futuresPubCall({ path: '/v1/exchangeInfo', method: 'GET', agent: agent });
    },
    futuresBook: function futuresBook(payload, agent) {
      return checkParams('futuresBook', payload, ['symbol']) && _futuresBook(futuresPubCall, payload, agent);
    },
    futuresTrades: function futuresTrades(payload, agent) {
      return checkParams('futuresTrades', payload, ['symbol']) && futuresPubCall({ path: '/v1/trades', method: 'GET', data: payload, agent: agent });
    },
    futuresTradesHistory: function futuresTradesHistory(payload, agent) {
      return checkParams('futuresTradesHistory', payload, ['symbol']) && futuresKCall({ path: '/v1/historicalTrades', method: 'GET', data: payload, agent: agent });
    },
    futuresAggTrades: function futuresAggTrades(payload, agent) {
      return checkParams('futuresAggTrades', payload, ['symbol']) && _futuresAggTrades(futuresPubCall, payload, agent);
    },
    futuresCandles: function futuresCandles(payload, agent) {
      return checkParams('futuresCandles', payload, ['symbol', 'interval']) && _futuresCandles(futuresPubCall, payload, agent);
    },
    // ______________ futures exclusive
    futuresChangePositionMode: function futuresChangePositionMode(payload, agent) {
      return checkParams('futuresChangePositionMode', payload, ['dualSidePosition']) && futuresPrivCall({ path: '/v1/positionSide/dual', data: _extends({}, payload, { dualSidePosition: payload.dualSidePosition ? 'true' : 'false' }), method: 'POST', agent: agent });
    },
    futuresGetPositionMode: function futuresGetPositionMode(payload, agent) {
      return futuresPrivCall({ path: '/v1/positionSide/dual', data: payload, method: 'GET', agent: agent });
    },

    futuresMarkPrice: function futuresMarkPrice(payload, agent) {
      return futuresPubCall({ path: '/v1/premiumIndex', data: payload, method: 'GET', agent: agent });
    },
    futuresFundingRate: function futuresFundingRate(payload, agent) {
      return checkParams('futuresFundingRate', payload, ['symbol']) && futuresKCall({ path: '/v1/fundingRate', data: payload, method: 'GET', agent: agent });
    },
    futuresDailyStats: function futuresDailyStats(payload, agent) {
      return futuresPubCall({ path: '/v1/ticker/24hr', data: payload, method: 'GET', agent: agent });
    },
    futuresPrice: function futuresPrice(payload, agent) {
      return futuresPubCall({ path: '/v1/ticker/price', data: payload, method: 'GET', agent: agent }).then(function (r) {
        return Array.isArray(r) ? payload.reduce && r.reduce(function (out, cur) {
          return out[cur.symbol] = cur.price, out;
        }, {}) || r : r;
      } // TODO: docs
      );
    }, // TODO: verify that adding reduce to the payload doesn't cause a problem
    // futuresAvgPrice: payload => futuresPubCall('/v3/avgPrice', payload),
    futuresBookTicker: function futuresBookTicker(payload, agent) {
      return futuresPubCall({ path: '/v1/ticker/bookTicker', data: payload, method: 'GET', agent: agent }).then(function (r) {
        return payload.reduce && Array.isArray(r) && r.reduce(function (out, cur) {
          return out[cur.symbol] = cur, out;
        }, {}) || r;
      } // TODO: docs
      );
    },
    futuresAllForceOrders: function futuresAllForceOrders(payload, agent) {
      return futuresPubCall({ path: '/v1/allForceOrders', data: payload, method: 'GET', agent: agent });
    },
    futuresOpenInterest: function futuresOpenInterest(payload, agent) {
      return checkParams('futuresOpenInterest', payload, ['symbol']) && futuresPubCall({ path: '/v1/openInterest', data: payload, method: 'GET', agent: agent });
    },
    futuresLeverageBracket: function futuresLeverageBracket(payload, agent) {
      return futuresPubCall({ path: '/v1/leverageBracket', data: payload, method: 'GET', agent: agent }).then(function (r) {
        return Array.isArray(r) ? payload.reduce && r.reduce(function (out, cur) {
          return out[cur.symbol] = cur.brackets, out;
        }, {}) || r : r.brackets;
      } // TODO: docs
      );
    },
    futuresAccountTransfer: function futuresAccountTransfer(payload, agent) {
      return checkParams('futuresAccountTransfer', payload, ['asset', 'amount', 'type']) && privCall({ path: '/sapi/v1/futures/transfer ', data: payload, method: 'POST', agent: agent });
    },
    // eslint-disable-next-line id-length
    futuresAccountTransactionHistory: function futuresAccountTransactionHistory(payload, agent) {
      return checkParams('futuresAccountTransactionHistory', payload, ['asset', 'startTime']) && privCall({ path: '/sapi/v1/futures/transfer', data: payload, method: 'GET', agent: agent });
    },
    futuresOrder: function futuresOrder(payload, agent) {
      return _futuresOrder(futuresPrivCall, payload, '/v1/order', agent);
    },
    futuresOrderTest: function futuresOrderTest(payload, agent) {
      return _futuresOrder(futuresPrivCall, payload, '/v3/order/test', agent);
    }, // TODO: remove
    futuresBatchOrders: function futuresBatchOrders(payload, agent) {
      return checkParams('futuresBatchOrders', payload, ['batchOrders']) && futuresPrivCall({ path: '/v1/batchOrders', data: payload, method: 'POST', agent: agent });
    },
    futuresGetOrder: function futuresGetOrder(payload, agent) {
      return checkParams('futuresQueryOrder', payload, ['symbol']) && futuresPrivCall({ path: '/v1/order', data: payload, agent: agent });
    },
    futuresCancelOrder: function futuresCancelOrder(payload, agent) {
      return checkParams('futuresCancelOrder', payload, ['symbol']) && futuresPrivCall({ path: '/v1/order', data: payload, method: 'DELETE', agent: agent });
    },
    futuresCancelAllOpenOrders: function futuresCancelAllOpenOrders(payload, agent) {
      return checkParams('futuresCancelOrder', payload, ['symbol']) && futuresPrivCall({ path: '/v1/allOpenOrders', data: payload, method: 'DELETE', agent: agent });
    },
    futuresCancelMultipleOrders: function futuresCancelMultipleOrders(payload, agent) {
      return checkParams('futuresCancelMultipleOrders', payload, ['symbol']) && futuresPrivCall({ path: '/v1/batchOrders', data: payload, method: 'DELETE', agent: agent });
    },
    futuresCountDownCancelAllOrders: function futuresCountDownCancelAllOrders(payload, agent) {
      return checkParams('futuresCountDownCancelAllOrders', payload, ['symbol', 'countdownTime']) && futuresPrivCall({ path: '/v1/countdownCancelAll', data: payload, method: 'POST', agent: agent });
    },
    futuresGetOpenOrder: function futuresGetOpenOrder(payload, agent) {
      return checkParams('futuresGetOpenOrder', payload, ['symbol']) && futuresPrivCall({ path: '/v1/openOrder', data: payload, method: 'GET', agent: agent });
    },
    futuresGetAllOpenOrders: function futuresGetAllOpenOrders(payload, agent) {
      return futuresPrivCall({ path: '/v1/openOrders', data: payload, method: 'GET', agent: agent });
    },
    futuresGetAllOrders: function futuresGetAllOrders(payload, agent) {
      return checkParams('futuresGetAllOrders', payload, ['symbol']) && futuresPrivCall({ path: '/v1/allOrders', data: payload, method: 'GET', agent: agent });
    },
    futuresAccountBalance: function futuresAccountBalance(payload, agent) {
      return futuresPrivCall({ path: '/v2/balance', data: payload, method: 'GET', agent: agent });
    },
    futuresAccountInfo: function futuresAccountInfo(payload, agent) {
      return futuresPrivCall({ path: '/v2/account', data: payload, method: 'GET', agent: agent });
    },
    futuresChangeLeverage: function futuresChangeLeverage(payload, agent) {
      return checkParams('futuresChange<Leverage', payload, ['symbol', 'leverage']) && futuresPrivCall({ path: '/v1/leverage', data: payload, method: 'POST', agent: agent });
    },
    futuresChangeMarginType: function futuresChangeMarginType(payload, agent) {
      return checkParams('futuresChangeMarginType', payload, ['symbol', 'marginType']) && futuresPrivCall({ path: '/v1/marginType', data: payload, method: 'POST', agent: agent });
    },
    futuresModifyPositionMargin: function futuresModifyPositionMargin(payload, agent) {
      return checkParams('futuresModifyPositionMargin', payload, ['symbol', 'amount']) && futuresPrivCall({ path: '/v1/positionMargin', data: payload, method: 'POST', agent: agent });
    },
    futuresPositionMarginHistory: function futuresPositionMarginHistory(payload, agent) {
      return checkParams('futuresPositionMarginHistory', payload, ['symbol']) && futuresPrivCall({ path: '/v1/positionMargin/history', data: payload, method: 'GET', agent: agent });
    },
    futuresPositionRisk: function futuresPositionRisk(payload, agent) {
      return futuresPrivCall({ path: '/v1/positionRisk', data: payload, method: 'GET', agent: agent });
    },
    futuresUserTrades: function futuresUserTrades(payload, agent) {
      return checkParams('futuresUserTrades', payload, ['symbol']) && futuresPrivCall({ path: '/v1/userTrades', data: payload, method: 'GET', agent: agent });
    },
    futuresIncomeHistory: function futuresIncomeHistory(payload, agent) {
      return futuresPrivCall({ path: '/v1/income', data: payload, method: 'GET', agent: agent });
    },
    futuresGetUserDataStream: function futuresGetUserDataStream(payload, agent) {
      return futuresPrivCall({ path: '/v1/listenKey', data: payload, method: 'POST', noData: true, agent: agent });
    },
    futuresKeepUserDataStream: function futuresKeepUserDataStream(payload, agent) {
      return futuresPrivCall({ path: '/v1/listenKey', data: payload, method: 'PUT', noData: false, noExtraData: true, agent: agent });
    },
    futuresCloseUserDataStream: function futuresCloseUserDataStream(payload, agent) {
      return futuresPrivCall({ path: '/v1/listenKey', data: payload, method: 'DELETE', noData: false, noExtraData: true, agent: agent });
    }
  };
};

/**
 * TODO: think about adding easy wait access (of every end point) (see local caching too)
 */